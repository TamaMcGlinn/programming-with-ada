####################
Four Months with Ada
####################

For the last four months I've been learning and writing Ada 2012.
This is a more in-depth examination of the language.
For those unfamiliar with Ada terms, I'll using the vernacular common to C family languages.
This will make Ada programmers cringe, but will be much more clear to the general reader.

**************************************************
A Free-Function Focused C++, or a Strongly Typed C
**************************************************

Ada focuses on creating packages of code which contain types and functions.
There's no preprocessor, so instead of ``#include``, you ``with`` packages which contain what you need.

.. code-block :: Ada

    with RT.Vecs; -- depend on another package, RT.Vecs

    package RT.Rays is
        use RT.Vecs;  -- use the names inside RT.Vecs

        type Ray is record
            Origin    : Point3;
            Direction : Vec3;
        end record;

        function Point_At(R : Ray; T: F32) return Point3;

    end RT.Rays;

Packages are namespaces for functions and types, unlike other languages where types can "contain" functions and types.
Function overloading acts as a key design element, made clear by the lack of implicit casts.

.. code-block :: Ada

    -- Idiomatic versions of "ToString"
    function Image(S : Some_Type) return String;
    function Image(A : Another_Type) return String;

Everything in a package is related, there's no syntactical split between "free function", "class function", or "member function" (method).

.. code-block :: Ada

    package RT.Vecs is
        type Vec3 is record
            X, Y, Z : F32 := 0.0;
        end record;

        function Length (V : Vec3) return F32;

        -- Is this a free function, a class function or a member function (method)?
        -- It doesn't really matter, because it's declared the same.
        function Dot (A, B : Vec3) return F32;
    end RT.Vecs

Functions all get declared similarly, only parameters and not syntax describes free functions vs instance functions.
Leading parameters determine if one would be considered a member function ("methods").

.. code-block :: Ada

    package SP.Filters is
        -- An empty "abstract class"
        type Filter is abstract tagged null record;

        -- A "pure virtual method"
        function Matches_Line (F : Filter; Str : String) return Boolean is abstract;

        -- Accepts any derived class of Filter
        function Matches_File (F : Filter'Class; Lines : String_Vectors.Vector) return Boolean;

        -- A "subclass"
        type Case_Sensitive_Match_Filter is new Filter with record
            Text : Unbounded_String;
        end record;

        -- An overridden method of a base class.
        overriding function Matches_Line (F : Case_Sensitive_Match_Filter; Str : String) return Boolean;

        -- "Free-function" which is just part of the package.
        function Is_Quoted (S : String) return Boolean;
    end SP.Filters

Packages are split between a "specification" (.ads file) and a "body" (.adb file), akin to the "header" and "source" files you encounter in C/C++.
However, this distinction is understood at the language level.

.. code-block :: Ada

    package body RT.Rays is
        -- Use all the operators of Vec3
        use all type RT.Vecs.Vec3;

        function Point_At(R : Ray; T: F32) return Point3 is (R.Origin + T * R.Direction);
    end RT.Rays;

Packages can contain startup code executed by the "environment task" prior to entering the main procedure for initialization.

.. code-block :: Ada

    package body RT.Debug is
    begin
        Ada.Text_IO.Put_Line("Executed before the program enters the main function!");
    end RT.Debug;

***************
Focus on Intent
***************

Parameter Modes
===============

Ada source focuses on describing intent and modeling semantics.
For example, function parameters can be either ``in``, ``out``, or both.
``in`` parameters are readonly, and while you can force passing by reference via specifics in the language, you often just ignore how this happens.
You can omit ``in`` parameters.

.. code-block :: Ada

    procedure Clear_Filters (Srch : in out Search);

    -- Like a "const" member function in C++, which can't modify its argument
    -- Could also be declared like this:
    -- function Num_Files (Srch : Search) return Natural;
    function Num_Files (Srch : in Search) return Natural;


Derived Types
=============

Describing semantics goes all the way into primitive types, and the rules are consistent between primitive and user-defined types.
Creating lightweight types with domain-specific meaning, prevents mishandling of semantics on primitive types due to no implicit casting.
Interfaces rarely use ``Integer`` or ``Float`` directly, instead you'll find semantic versions ("derived types") created such as "Meters" or "Kilometers".

.. code-block :: Ada

    type Seconds is new Natural;
    type Milliseconds is new Natural;

    S : Seconds := 10;
    M : Milliseconds := 50;

    M := S;                       -- Compile error!
    M := Milliseconds (1000 * S); -- Allowed because I told compiler it's ok

Function overloading checks parameters as well as return types, so creating functions and transforms of types is straightforward.

.. code-block :: Ada

    procedure Update (S : Seconds);
    procedure Update (M : Milliseconds);

    function Delta_Time return Seconds;
    function Delta_Time return Milliseconds;

Compile and runtime checks provide bounds-checking and numerical types can have their bounds constrained to "known good" values.

.. code-block :: Ada

    -- Let's write this with our own defined range, only allowing less than 60 seconds.
    -- type Seconds is new Natural;
    type Seconds is new Integer range 0 .. 59;

You can also access the ranges of types with the ``'First`` and ``'Last`` attributes (read as "tick first" and "tick last").

.. code-block :: Ada

    pragma Assert(Seconds'First = 0);
    pragma Assert(Seconds'Last = 59);

Enumeration Types
=================

Enumeration types have first class support, with many automatically generated attributes.
``'First`` and ``'Last`` get the bounds of the values and ``'Pred`` (predecessor) and ``'Succ`` move between individual values.
Iteration over all values and conversions to and from strings and integers get provided for free.
Together, these attributes and iteration capability allow writing of generic code which operates on discrete types like integers, or enumerations.

.. code-block :: Ada

    with Ada.Unchecked_Conversion;

    type Filter_Action is (Keep, Exclude);    

    -- Specify internal values for the enumeration (optional).
    for Filter_Action use (
        Keep => 2,
        Exclude => 3
    );

    -- Allow conversion to get the values out
    function Repr is new Ada.Unchecked_Conversion(Filter_Action, Integer);

    procedure Print_Actions is
    begin
        -- Which order are they in?
        pragma Assert(Keep = Filter_Action'Val(0));
        pragma Assert(Exclude = Filter_Action'Val(1));
        pragma Assert(0 = Filter_Action'Pos(Keep));
        pragma Assert(1 = Filter_Action'Pos(Exclude));

        -- Comparison operators
        pragma Assert(Keep /= Exclude);  -- /= is Ada's not equal (i.e. !=)
        pragma Assert(Keep < Exclude);

        pragma Assert(Filter_Action'First = Keep);
        pragma Assert(Filter_Action'Last = Exclude);
        pragma Assert(Filter_Action'Succ(Keep) = Exclude);
        pragma Assert(Filter_Action'Pred(Exclude) = Keep);

        -- Parsing from string
        pragma Assert(Filter_Action'Value("KEEP") = Keep);
        pragma Assert(Filter_Action'Value("Exclude") = Exclude);

        -- Getting underlying representation
        pragma Assert(2 = Repr(Keep));
        pragma Assert(3 = Repr(Exclude));

        for Action in Filter_Action loop
            Ada.Text_IO.Put_Line(Action'Image);  -- Prints KEEP and then EXCLUDE
        end loop;
    end Print_Actions;

Since arrays operate using a discrete type as an index, enumerations can be used as the type to index into an array.

.. code-block :: Ada

    type Test_Status is (Passed, Failed, Skipped);
    type Test_Report is array (Test_Status) of Natural;

    procedure Foo is
        Report : Test_Report;
    begin
        -- ...

        -- Increment number of passed tests.
        Report(Passed) := Report(Passed) + 1;

        -- ...


Pre- and Post-Conditions
========================

Ada adds built-in support for pre and post conditions, through the use of "aspects."
This is a "killer feature" of Ada 2012, on top of all of the other type checking and safety checking, pre and post conditions get provided as part of the specification of the function.
Clients can see it as part of the interface and the compiler inserts runtime checks if enabled.
A lot of languages have an assertion mechanism which often effectively gets used for these checks, but a built-in way of doing this which shows up in the interface is a major game changer.
I found that adding pre and post condition checks during debugging to be a very effective tool.

.. code-block :: Ada

    function Merge (A, B : Context_Match) return Context_Match with
        Pre  => Is_Valid (A) and then Is_Valid (B),
        Post => Is_Valid (Merge'Result);

Types which expose no private state can also have type invariants which are checked prior to usage as function arguments and after assignments.

.. code-block :: Ada

   type Spinner is record
       Ticks_Per_Move : Positive;
       Ticks          : Natural;
       State          : Spinner_State;
       Style          : Spinner_Style;
   end record with
       Type_Invariant => Ticks < Ticks_Per_Move;

Discriminants
=============

Another strange concept which I hadn't seen before, is that types can be "parameterized" at runtime using what is called a "discriminant."
It's a sort of read-only constant field which is part of the record.

This read only value becomes part of the type and whether explicitly described or not affects type checking.
An extremely commonly used one is with the built-in String type in which the string's length is given by the discriminant.

Protected Objects
=================

Protected objects coordinate concurrent access to shared state.
The control can also include arbitrarily complex conditionals as well, such as not allowing any writers when readers exist, or blocking any more readers when a writer is waiting.

Tasks
=====

Tasks provide concurrent execution.
Additionally, they have special procedures called "entries" which can be "accepted" by a related task during its flow of execution to synchronize (rendezvous) with other tasks and share data at these points.

Tasks run concurrently in the block in which they're declared, and the block will not exit until the task finishes or terminates, unless it is allocated on the heap.

Both single instance and instantiable versions of protected objects and tasks can be created.

Generics
========

Generic packages or functions must be explicitly instantiated for use.
This eliminates the debate of angled brackes (<>) versus square brackets for generics ([]), but leads to additional names being created.
The benefit of this is making their usage, and hence their cost, explicit, at the expense of verboseness.

*****************
Low Level Control
*****************

Accessing C functions and compiler intrinsics is straightforward.
You create a declaration of the subprogram and then describe where it comes from using aspects or the ``Import`` pragma.

.. code-block :: Ada

    with Interfaces.C;

    type FD is new Interfaces.C.int;
    function isatty (File_Descriptor : FD) return BOOL with
        Import     => True,
        Convention => C;

    -- Bring in the stdout file pointer from C
    type FILE_Ptr is new System.Address;
    stdout : aliased FILE_Ptr;
    pragma Import (C, stdout, "stdout");

Using representation clauses makes it trivial to match C struct layout or binary formats such as for files.
Since the usage is the same as with an Ada function, imported functions can be replaced easily if needed.
Inline assembler is also available, but due to the lack of a preprocessor, the build system (gpr) is leveraged to choose the appropriate definition (body) file to compile.

.. code-block :: Ada

    function File_Line return Natural;
    pragma Import (Intrinsic, File_Line, "__builtin_LINE");

*******************
Hurdles to Adoption
*******************

License Confusion
=================

The material and information provided on this site is for general information
purposesly only.

I am not a not a lawyer and I am not providing legal advice.
The information here is for informational purposes only and not for the purpose of providing legal advice.
You should contact a qualified You should consult with a qualified and licensed lawyer


*****
Alire
*****

Alire simplifies Ada development significantly, by simplifying project generation,
building, running, and dependency management.

It borrows heavily from Cargo.
If good arts borrow, and great artists steal, then Ada is on par with Michaelangelo.
In its quest for modernizing, many concepts of Rust's cargo are being built in to a similar tool for Ada called Alire.
This tool only went to 1.0 since I've been working with Ada, but iot simplifies building and editing considerably.
Getting dependencies and setting up projects also gets streamlined significantly.
The toolchain itself will eventually be integrated into this tool, so it will become a sort of one-stop shop for downloading things for Ada.

There's a bit of jank to get a crate into the manager.
Every package and version update requires manual approval for now.
While this prevents name squatting and ensures existing libraries can get their appropriate names,
it can be frustrating waiting for approval even though things usually get approved quickly.

You can use local unpublished versions as a dependency, which helps when developing libraries,
and keeps you moving if you're waiting that day for approval.

Overall, Alire makes it incredibly easy to split up your project into multiple libraries.

Cross-Platform Behavior
=======================

Alire hooks into GPRbuild's external variable system for cross-platform behavior.

.. code-block :: TOML

    # alire.toml
    # Platform selection by Alire on download.
    [gpr-set-externals.'case(os)']
    windows = { Trendy_Terminal_Platform = "windows" }
    linux = { Trendy_Terminal_Platform = "linux" }
    macos = { Trendy_Terminal_Platform = "macos" }


.. code-block :: Ada

    -- my_project.gpr
    type Platform_Type is ("windows", "linux", "macos");
    Platform : Platform_Type := external ("Trendy_Terminal_Platform");
    case Platform is
        when "windows" => Trendy_Terminal_Sources := Trendy_Terminal_Sources & "src/windows";
        when "linux"   => Trendy_Terminal_Sources := Trendy_Terminal_Sources & "src/linux";
        when "macos"   => Trendy_Terminal_Sources := Trendy_Terminal_Sources & "src/mac";
    end case;

Right now, Ada is a playground for library and tool writers.  It's a mature language with
excellent C compatibility in need of a lot of basic libraries.  In addition, it provides
the means to create, distribute and use formally verified libraries.  This isn't some
hypothetical pipe dream anymore.  This means formally verified programs are here for
the main stream.  adaCore does have the highest level selvers bheind a paywall of paid support,
but "silver" level programs and libraries are here.




Ada suffers from a lack of familiarity for many programmers due to being a Pascal family language and also its peculiar, but very specific vocabulary.
It's not as obscure to learn as you think it would be.
The usage of keywords over punctuation helps ease many problems of dealign with an unfamiliar language.
While this helps with googling, a lot of uncommon terms are specific to, or have Ada-specific terms.

# UNUSED, DO NOT SUBMIT

Ada is a honey badger that just doesn't care.

Ada focuses on intent, usually describing the goal, rather than focusing on the method.

The language writes like free-function focused C++, or a strongly typed C.
Packages act as namespaces and though functions can be considered "primitive operations" of a type, types are not namespaces for functions or other types.
These also act as namespaces for functions instead of types themselves, so no distinction exists between between how "free functions", "class functions", and "member functions" are declared, they're all just functions within a package.
This seems bizarre but it plays into the extensive use of function overloading in the language.